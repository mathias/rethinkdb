#!/bin/bash
# Copyright 2010-2013 RethinkDB, all rights reserved.

set -e
set -u

if [ "0${BASH_VERSION%%.*}" -lt 4 ]; then
    echo "* Error: Bash version 4 or greater is required" >&2
    exit 1
fi

init () {
    min_gcc_version=$(read_version 4.5.0)
    min_clang_version=0
    min_icc_version=0

    required_libs="boost_serialization boost_program_options protobuf v8"
    other_libs="unwind tcmalloc_minimal"
    all_libs="$required_libs $other_libs"
    support_libs="unwind tcmalloc_minimal v8"
    mostly_recommended_static="boost_serialization boost_program_options protobuf"
    recommended_static="tcmalloc_minimal"
    default_static="$mostly_recommended_static $recommended_static"

    npm_deps="lessc coffee handlebars"
    required_bin_deps="protoc node $npm_deps"
    support_bin_deps="$required_bin_deps npm"
    support_deps="$support_bin_deps $support_libs"
    bin_deps="cxx $support_bin_deps"
    all_deps="$bin_deps $all_libs"

    allowed_arg_vars="CXXFLAGS LDFLAGS"
}

configure () {
    for var in $allowed_arg_vars; do
        local val
        if lookup "$arg_vars" $var val; then
            require $var
            var $var "$val"
        fi
    done
    var LIB_SEARCH_PATHS "$lib_paths"
    require "Operating System"
    var OS $(uname)
    case "$OS" in
        Darwin)
            with_tcmalloc=false
            force_paths="$force_paths boost_program_options=/usr/local/lib/libboost_program_options-mt.a protobuf=/usr/local/lib/libprotobuf.a"
            ;;
        Linux) true ;;
        *) error "unsupported operating system: $OS" ;;
    esac
    require "Use tcmalloc"
    boolvar NO_TCMALLOC $with_tcmalloc
    require "Build client drivers"
    boolvar BUILD_DRIVERS $enable_drivers
    require "Architecture"
    var GCC_ARCH $(uname -m | grep '^[A-Za-z0-9_]*$' | head -n 1)
    var GCC_ARCH_REDUCED $(echo "$GCC_ARCH" | sed -e 's/^i[56]86$$/i486/g')
    var DEB_ARCH $(echo "${GCC_ARCH_REDUCED:-}" | sed -e 's/^x86_64$$/amd64/g')
    require "C++ Compiler"
    check_cxx
    for bin in $required_bin_deps; do
        require_dep $bin
        check_bin $bin
    done
    if any "$fetch_list" contains "$npm_deps"; then
        require_dep npm
        check_bin npm
    fi
    for lib in $required_libs; do
        require_dep $lib
        check_lib $lib
    done
    if [[ $NO_TCMALLOC = 0 ]] ; then
        require_dep tcmalloc_minimal
        check_lib tcmalloc_minimal
        if contains "$fetch_list" tcmalloc_minimal; then
            require_dep unwind
            check_lib unwind
        fi
    fi
    var FETCH_LIST "$fetch_list"
    var ALLOW_INTERNAL_TOOLS $($allow_fetch && echo 1 || echo 0)
    require Installation prefix
    var PREFIX ${arg_prefix:-/usr/local}
    require Configuration prefix
    var SYSCONFDIR ${arg_sysconfdir:-$PREFIX/etc}
    require Runtime data prefix
    var LOCALSTATEDIR ${arg_localstatedir:-$PREFIX/var}
}

main () {
    init

    read_args "$@"
    
    echo "* Detecting system configuration"

    trap "show error; echo '* Aborting configure'" EXIT

    success=false
    write "# Automatically generated by $0" 3> "$config"
    write "# Command line: $@" 3>> "$config"
    write "CONFIGURE_STATUS := started" 3>> "$config"
    write "CONFIGURE_ERROR := " 3>> "$config"
    configure 3>> "$config"

    trap - EXIT
    
    if ! $failed; then
        write "CONFIGURE_STATUS := done" 3>> "$config"
        echo "* Wrote configuration to $config"
    else
        write "CONFIGURE_STATUS := failed" 3>> "$config"
        echo "* Aborting configure"
        exit 1
    fi
    
}

read_args () {
    local no_arg
    local has_arg
    local arg
    local option
    local dep

    exit_on_error=true
    config=config.mk
    failed=false

    allow_fetch=false
    fetch_list=
    force_paths='= '
    can_show=false
    required=false
    arg_vars=$'\1\2'
    lib_paths=
    static_libs=$default_static
    arg_prefix=
    arg_sysconfdir=
    arg_localstatedir=
    with_tcmalloc=true
    enable_drivers=true

    while [[ $# -ne 0 ]]; do
        arg=${1#*=}
        if [[ "$arg" = "$1" ]]; then
            no_arg=shift
            if [[ $# -eq 1 ]]; then
                has_arg="error_missing_arg $(quote "$1")"
            else
                arg=$2
                has_arg='shift 2'
            fi
        else
            no_arg="error_no_arg $(quote "$1")"
            has_arg=shift
        fi
        option="${1%%=*}"
        case "$option" in
            --debug-configure) $no_arg; set -x ;;
            --config) $has_arg; config=$arg ;;
            --continue) $no_arg; exit_on_error=false ;;
            --allow-fetch) $no_arg; allow_fetch=true ;;
            --force-fetch) $has_arg
                allow_fetch=true
                if [[ "$arg" = "all" ]]; then
                    fetch_list="$support_deps"
                elif contains "$support_deps" "$arg"; then
                    fetch_list="$fetch_list $arg"
                else
                    die "Don't know how to fetch '$arg'" 
                fi ;;
            --static) $has_arg
                if [[ "$arg" = default ]]; then
                    static_libs=$default_static
                elif [[ "$arg" = recommended ]]; then
                    static_libs=$recommended_static
                elif [[ "$arg" = none ]]; then
                    static_libs=
                elif [[ "$arg" = all ]]; then
                    static_libs=$all_libs
                elif contains "$all_libs" "$arg"; then
                    static_libs="$static_libs $arg"
                else
                    die "Unknown static library: $arg"
                fi ;;
            --lib-path) $has_arg; lib_paths="$lib_paths $arg" ;;
            --with-tcmalloc) $no_arg; with_tcmalloc=true ;;
            --without-tcmalloc) $no_arg; with_tcmalloc=false ;;
            --enable-drivers) $no_arg; enable_drivers=true ;;
            --disable-drivers) $no_arg; enable_drivers=false ;;
            --prefix) $has_arg; arg_prefix=$arg ;;
            --sysconfdir) $has_arg; arg_sysconfdir=$arg ;;
            --localstatedir) $has_arg; arg_localstatedir=$arg ;;
            --help) show_help; exit ;;
            -*) die "Unknown option '$option'" ;;
            *) if contains "$bin_deps" "${option,,}"; then
                 $has_arg
                 force_paths="$force_paths ${option,,}=$arg "
               elif contains "$allowed_arg_vars" "$option"; then
                 $has_arg
                 arg_vars="$arg_vars"$'\2'"$option"$'\1'"$arg"
               else
                 die "Unknown variable argument: $option"
               fi ;;
        esac
    done
}

dep_descrs=':
cxx:C++ Compiler
protoc:Protobuf compiler
node:Node.js
npm:Node.js package manager
lessc:LESS css
coffee:CoffeScript
handlebars:Handlebars
unwind:libunwind
tcmalloc_mininaml:Google Perf Tools library'

show_help () {
    cat <<EOF
Configure a RethinkDB build from source

Usage: $0 [arguments]

  --help                  Display this help
  --config <file>         Output file (default config.mk)
  --continue              Do not stop after encountering an error

  --allow-fetch           Allow fetching missing dependencies
  --lib-path <dir>        Add dir to the library search path
  <var>=<val>             Set the value of a variable
                            CXXFLAGS  C++ compiler arguments
                            LDFLAGS   C++ linker arguments
  --force-fetch <dep>     Force fetching <dep>.
  <DEP>=<path>            Library or executable path. <dep> can be
EOF
    for dep in $all_deps; do
        local padded="$dep                        "
        local descr
        lookup "$dep_descrs" $dep descr || descr=
        echo "                            ${padded:0:24} $descr"
    done
    cat <<EOF
  --static <lib>          Statically link some libraries. <lib> is a library <dep> or one of:
                            all          All libraries
                            recommended  Highly recommended libraries
                            default      Recommended libraries
                            none         No static libraries
  --prefix <dir>          Installation prefix. Defaults to /usr/local
  --sysconfdir <dir>      Configuration prefix. Defaults to /usr/local/etc
  --localstatedir <dir>   Runtime data prefix. Defaults to /usr/local/var
  --with-<module>
  --without-<module>      enable or disable <module>. <module> can be one of
                            tcmalloc     Build with tcmalloc. (Default: enabled)
EOF
}

quote () {
    printf %q "$1"
}

error_no_arg () {
    die "option ${1%%=*} does not take any arguments"
}

error_missing_arg () {
    die "option ${1%%=*} takes an argument"
}

error () {
    local req=$required
    show error
    local type=Error
    $req || type=Warning
    echo "* $type: $*" >&2
    write "CONFIGURE_ERROR := $*"
    if $exit_on_error && $req; then
        exit 1
    fi
    failed=$req
}

die () {
    show error
    required=true
    error "$@"
    exit 1
}

not_found () {
    show "no"
    if contains "$support_list" "$1"; then
        error "missing $1. Install it, specify the full path with ${1^^}= or run ./configure with --allow-fetch"
    else
        error "missing $1. Install it or specify the full path with ${1^^}="
    fi
}

write () {
    echo "$*" >&3
}

show_descr () {
    local ret=0
    if ${can_show:-false}; then
        error "Could not detect value" 
        ret=1
    fi
    local padded="$*:                        "
    echo -n "${padded:0:25}"
    write "# $*"
    can_show=true
    return $ret
}

show () {
    if $can_show; then
        echo "$*"
        can_show=false
        required=true
    fi
}

require () {
    required=true
    show_descr "$@"
}

optional () {
    required=false
    show_descr "$@"
}

var () {
    local name=$1
    shift
    local val=$*
    show "$val"
    write "$name ?= $val"
    eval "$name=$(quote "$val")"
}

var_append () {
    local name=$1
    shift
    local val=$*
    show "$val"
    write "$name += $val"
}

boolvar () {
    local name=$1
    shift
    if "$@"; then
        show yes
        var $name 1
    else
        show no
        var $name 0
    fi
}

check_cxx () {
    lookup "$force_paths" cxx force_CXX || :
    CXX=${force_CXX:-${CXX:-c++}}
    CXX=$(which "$CXX")
    if [[ ! -x "$CXX" ]]; then
        if [[ -n ${force_CXX:-} ]]; then
            error "unable to run $force_CXX"
            return
        fi
        CXX=$(which g++ || which clang || which icc)
        if [[ -z "$CXX" ]]; then
            not_found CXX
            return
        fi
    fi
    local description=$($CXX --version 2>/dev/null)$($CXX --help 2>/dev/null)
    local version_string=$(echo "$description" | egrep -o '[0-9]+\.[0-9]+(\.[0-9]+)?'| head -n 1)
    local type=$(echo "$description" | egrep -io 'gcc|g\+\+|clang|icc' | head -n 1)
    case "${type^^}" in
        GCC|G++) min_version=$min_gcc_version
                 type=GCC ;;
        CLANG) min_version=$min_clang_version ;;
        ICC) min_version=$min_icc_version
             type=INTEL ;;
        *) show "unknown"
           error "Could not determine C++ compiler type (gcc, clang or icc is required)"
           return
    esac
    if [[ -z "$version_string" ]]; then
        show "${type^^} (unknown version)"
        error "Could not determine C++ compiler version (>= $(write_version $min_version) required)"
        return
    else
        test_version_gt ${type^^} $min_version $(read_version "$version_string") || return
    fi
    
    show "${type^^} $version_string ($CXX)"
    var COMPILER "" "${type^^}"
    var CXX "" "$CXX"
}

read_version () {
    local one=${1%%.*}
    local rest=${1#*.}
    local two=${rest%%.*}
    rest=${rest#*.}
    local three=${rest%%.*}
    if [[ "$three" != "$rest" ]]; then three=0; fi
    printf %d%02d%02d "$one" "$two" "$three"
}

write_version () {
    local v=$(printf %06d "$1")
    printf %d.%d.%d ${v:0:2} ${v:2:2} ${v:4:2}
}

test_version_gt () {
    if [[ $2 -gt $3 ]]; then
        show "too old"
        error "$1 $(write_version $3) is too old. At least $1 $(write_version $2) is required"
        return 1
    fi
}

contains () {
    d=" $1 "
    [[ "${d/ $2 /}" != "$d" ]]
}

any () {
    local list=$1
    shift
    for x in $list; do
        if "$@" $x; then
            return 0
        fi
    done
    return 1
}

# lookup <dict> <key> [var]
# dict is composed of two seperators followed by a list of pairs
# eg: ':|foo:bar|test:123|baz:quux' or '= a=b c=d'
lookup () {
    local _val=${1#*${1:1:1}$2${1:0:1}}
    if [[ "$_val" = "$1" ]]; then
        unset ${3:-$2}
        return 1
    fi
    eval "${3:-$2}=$(quote "${_val%%${1:1:1}*}")"
}

check_bin () {
    if contains "$fetch_list" $1; then
        fetch_bin $1
        return
    fi
    local force_bin
    lookup "$force_paths" $1 force_bin || :
    local bin=${force_bin:-${!1:-$1}}
    bin=`which "$bin"`
    if [[ ! -x "$bin" ]]; then
        if [[ -n ${force_bin:-} ]]; then
            error "unable to run $force_bin"
            return
        fi
        if $allow_fetch && contains "$support_bin_deps" $1; then
            fetch_list="$fetch_list $1"
            fetch_bin $1
            return
        else
            not_found ${1^^}
            return
        fi
    fi
    var "${1^^}" "$bin"
}

fetch_bin () {
    show fetch
    var ${1^^} "\$(TC_${1^^}_INT_EXE)"
    fetch_list="$fetch_list $1"
}

fetch_lib () {
    show fetch
    var_append LIBRARY_PATHS "\$(${1^^}_INT_LIB)"
    var ${1^^} "\$(${1^^}_INT_LIB)"
    fetch_list="$fetch_list $1"
}

require_dep () {
    local descr
    lookup "$dep_descrs" $1 descr || descr=$1
    require $descr
}

optional_dep () {
    local descr
    lookup "$dep_descrs" $1 descr || descr=$1
    optional $descr
}

check_lib () {
    # TODO: pkg_config, osx
    local path
    if ! lookup "$force_paths" $1 path; then
        if contains "$fetch_list" $1; then
            fetch_lib $1
            return 0
        fi
        path=$(ldconfig_lookup $1)
        if contains "$static_libs" $1; then
            local static_path="${path/.so/.a}"
            if [[ -e "$static_path" ]]; then
                var_append LIBRARY_PATHS "$static_path"
            else
                if contains "$support_deps" $1 && $allow_fetch; then
                    fetch_lib $1
                else
                    error "library $1 not found"
                fi
            fi
        elif [ -n "$path" ]; then
            var_append RT_LDFLAGS "-l$1"
        else
            if contains "$support_deps" $1 && $allow_fetch; then
                fetch_lib $1
            else
                error "library $1 not found"
            fi
        fi
    else
        var_append LIBRARY_PATHS "$path"
    fi
}

ldconfig_lookup () {
    which ldconfig >/dev/null && ldconfig -p | awk "/lib$1.so / { print \$NF }" | head -n 1
}

main "$@" 3>/dev/null